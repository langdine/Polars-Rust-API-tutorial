# over示例

over在表达式中指定分组列，这使得你不需要在运算前应用group_by。表达式在组内应用,聚合函数返回值会为组内每个元素出现一次。over的效果相当于group_by+聚合+join

```rust
use polars::prelude::*;
fn main() ->Result<(), PolarsError> {
let df = df![
"类别" => ["开发","开发","开发","开发","开发","实习","实习","销售","销售","销售"],
"员工ID" => [11,7,9,8,10,5,2,3,1,4],
"薪水" => [5200,4200,4500,6000,5200,3500,3900,4800,5000,4800],
]?;
//我们有一份员工薪水列表，我们想了解各个岗位员工薪水的排位情况。
let imploded = df.lazy()
    .select([
        col("*"),
        col("薪水").mean().alias("平均薪水").over([col("类别")]),
        col("薪水").rank(RankOptions::default(),None).over([col("类别")]).alias("薪水rank over类别"),
        col("薪水").rank(RankOptions::default(),None).alias("薪水rank")
    ]);

```
Output
```bash
shape: (10, 6)
┌──────┬────────┬──────┬─────────────┬───────────────────┬──────────┐
│ 类别 ┆ 员工ID ┆ 薪水 ┆ 平均薪水    ┆ 薪水rank over类别 ┆ 薪水rank │
│ ---  ┆ ---    ┆ ---  ┆ ---         ┆ ---               ┆ ---      │
│ str  ┆ i32    ┆ i32  ┆ f64         ┆ u32               ┆ u32      │
╞══════╪════════╪══════╪═════════════╪═══════════════════╪══════════╡
│ 开发 ┆ 11     ┆ 5200 ┆ 5020.0      ┆ 3                 ┆ 7        │
│ 开发 ┆ 7      ┆ 4200 ┆ 5020.0      ┆ 1                 ┆ 3        │
│ 开发 ┆ 9      ┆ 4500 ┆ 5020.0      ┆ 2                 ┆ 4        │
│ 开发 ┆ 8      ┆ 6000 ┆ 5020.0      ┆ 4                 ┆ 8        │
│ 开发 ┆ 10     ┆ 5200 ┆ 5020.0      ┆ 3                 ┆ 7        │
│ 实习 ┆ 5      ┆ 3500 ┆ 3700.0      ┆ 1                 ┆ 1        │
│ 实习 ┆ 2      ┆ 3900 ┆ 3700.0      ┆ 2                 ┆ 2        │
│ 销售 ┆ 3      ┆ 4800 ┆ 4866.666667 ┆ 1                 ┆ 5        │
│ 销售 ┆ 1      ┆ 5000 ┆ 4866.666667 ┆ 2                 ┆ 6        │
│ 销售 ┆ 4      ┆ 4800 ┆ 4866.666667 ┆ 1                 ┆ 5        │
└──────┴────────┴──────┴─────────────┴───────────────────┴──────────┘
```
